Харківський національний університет радіоелектроніки
Факультет комп'ютерних наук
Катедра програмної інженерії






ЗВІТ
з практичного заняття №1
з дисципліни  «Архітектура програмного забезпечення»
на тему: «Патерни проєктування»






Виконав
ст. гр. ПЗПІ-22-3
Ткаченко Євген Андрійович

Перевірив
ст. викладач катедри ПІ
Сокорчук Ігор Петрович



Харків 2025
ІСТОРІЯ ЗМІН
 
№	Дата	Версія звіту	Опис змін та виправлень
1	12.04.2025	0.1	Створено загальну структуру звіту
2	12.04.2025	0.1	Створено пункти «Завдання»
3	12.04.2025	0.1	Створено пункти «Опис виконаної роботи»
4	13.04.2025	0.1	Заповнено додаток Б та В. Надано приклади коду.
5	13.04.2025	0.1	Створено посилання на відео з доповіддю










1 ЗАВДАННЯ

Дослідити програмний патерн Фабричний метод, його призначення, структуру, особливості реалізації та практичне застосування в об'єктноорієнтованому програмуванні. Продемонструвати принципи роботи патерну на конкретних прикладах програмного коду для унаочнення його застосування в розробці програмного забезпечення.

2 ОПИС ВИКОНАНОЇ РОБОТИ

Було сформовано доповідь. Її розказано у вигляді відео, посилання на яке розміщено в додатку А. Слайди презентації наведено в додатку Б. Код, який аналізували як приклади, наведено в додатку В.
Ця доповідь занурює нас у світ патерну "Фабричний метод" — одного з ключових породжувальних патернів проєктування, який забезпечує гнучке створення об’єктів без прямої залежності від конкретних класів. Ми досліджуємо, як сучасні програмні системи потребують масштабованості, розширюваності та здатності адаптуватися до змін без переписування основної логіки. У цьому контексті "Фабричний метод" постає як ефективне рішення, що дозволяє делегувати створення об’єктів підкласам.
У доповіді розкриваються основи роботи патерну, його архітектура та типові сценарії використання — від UI-компонентів у Android до HTTP-клієнтів у Kotlin. Розглянуто приклади реалізації фабричних методів на мові Kotlin, що демонструють, як патерн сприяє дотриманню принципів SOLID та спрощенню підтримки коду. Зокрема, ми аналізуємо створення кнопок для Android та iOS, ієрархії повідомлень та динамічної обробки API-запитів. Усі приклади супроводжуються фрагментами коду та поясненням їхньої ролі в архітектурі застосунку.
Презентація також охоплює переваги "Фабричного методу" — від інкапсуляції логіки створення до можливості легко замінювати реалізації без впливу на клієнтський код. Окремо наголошується на недоліках, таких як збільшення кількості класів та початкова складність розуміння для початківців. Крім того, ми демонструємо приклади використання патерну в популярних інструментах екосистеми Kotlin і Android: Room, Retrofit, ViewModelProvider.
Було сформовано доповідь. Її розказано у вигляді відео, посилання на яке розміщено в додатку А. Слайди презентації наведено в додатку Б. Код, який аналізували як приклади, наведено в додатку В.
Ця доповідь занурює нас у світ патерну "Фабричний метод" — одного з ключових породжувальних патернів проєктування, який забезпечує гнучке створення об’єктів без прямої залежності від конкретних класів. Ми досліджуємо, як сучасні програмні системи потребують масштабованості, розширюваності та здатності адаптуватися до змін без переписування основної логіки. У цьому контексті "Фабричний метод" постає як ефективне рішення, що дозволяє делегувати створення об’єктів підкласам.
У доповіді розкриваються основи роботи патерну, його архітектура та типові сценарії використання — від UI-компонентів у Android до HTTP-клієнтів у Kotlin. Розглянуто приклади реалізації фабричних методів на мові Kotlin, що демонструють, як патерн сприяє дотриманню принципів SOLID та спрощенню підтримки коду. Зокрема, ми аналізуємо створення кнопок для Android та iOS, ієрархії повідомлень та динамічної обробки API-запитів. Усі приклади супроводжуються фрагментами коду та поясненням їхньої ролі в архітектурі застосунку.
Презентація також охоплює переваги "Фабричного методу" — від інкапсуляції логіки створення до можливості легко замінювати реалізації без впливу на клієнтський код. Окремо наголошується на недоліках, таких як збільшення кількості класів та початкова складність розуміння для початківців. Крім того, ми демонструємо приклади використання патерну в популярних інструментах екосистеми Kotlin і Android: Room, Retrofit, ViewModelProvider.


ВИСНОВКИ

У результаті виконання даної практичної роботи було розглянуто Фабричний метод. З’ясовано його переваги та недоліки. Описано доцільність його використання.

























ДОДАТОК А
Посилання на відеозапис доповіді

Відеозапис доповіді на YouTube: https://youtu.be/QpXkD6nI8uo

























ДОДАТОК Б
Слайди презентації доповіді
  
Рисунок Б.1 – Титульний слайд
 
 
Рисунок Б.2 – Зміст


 
Рисунок Б.3 – Вступ: Що таке патерн проєктування?

 
Рисунок Б.4 – Що таке патерн "Фабричний метод"?

 
Рисунок Б.5 – Де використовується патерн "Спостерігач"?

 
Рисунок Б.6 – Архітектура та принцип роботи

 
Рисунок Б.7 – Класична реалізація патерна в Kotlin

 
Рисунок Б.8 – Переваги методу

 
Рисунок Б.9 – Недоліки методу

 
Рисунок Б.10 – Приклад 1: Android кнопки

 
Рисунок Б.11 – Приклад 2: Повідомлення

 
Рисунок Б.12 – Використання патерна в стандартних бібліотеках

 
Рисунок Б.13 – Висновки

 
Рисунок Б.14 – Джерела





ДОДАТОК В
Приклади програмного коду

1. interface Dialog {
2.     fun render()
3. }
4. 
5. class WindowsDialog : Dialog {
6.     override fun render() = println("Rendering Win dialog")
7. }
8. 
9. class LinuxDialog : Dialog {
10.     override fun render() = println("Rendering Linux dialog")
11. }

1. abstract class DialogFactory {
2.     abstract fun createDialog(): Dialog
3. }
4. 
5. class WindowsDialogFactory : DialogFactory() {
6.     override fun createDialog() = WindowsDialog()
7. }

1. abstract class Button {
2.     abstract fun render()
3. }
4. 
5. class AndroidButton : Button() {
6.     override fun render() = println("Android Button")
7. }
8. 
9. class IOSButton : Button() {
10.     override fun render() = println("iOS Button")
11. }

1. class ButtonFactory {
2.     fun getButton(type: String): Button = when (type) {
3.         "android" -> AndroidButton()
4.         "ios" -> IOSButton()
5.         else -> throw IllegalArgumentException("Unknown type")
6.     }
7. }
8. 

1. interface Message {
2.     fun send()
3. }
4. 
5. class EmailMessage : Message {
6.     override fun send() = println("Sending Email")
7. }
8. 
9. class SmsMessage : Message {
10.     override fun send() = println("Sending SMS")
11. }

1. fun messageFactory(type: String): Message = when(type) {
2.     "email" -> EmailMessage()
3.     "sms" -> SmsMessage()
4.     else -> throw IllegalArgumentException("Unknown")
5. }

